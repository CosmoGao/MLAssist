// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: CGData.proto
#ifndef GRPC_CGData_2eproto__INCLUDED
#define GRPC_CGData_2eproto__INCLUDED

#include "CGData.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace CGData {

// HookDll用来通信，暂时不启用
class MLRpcService final {
 public:
  static constexpr char const* service_full_name() {
    return "CGData.MLRpcService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Initialize(::grpc::ClientContext* context, const ::CGData::CGGmeTypeRequest& request, ::CGData::CGVoidData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>> AsyncInitialize(::grpc::ClientContext* context, const ::CGData::CGGmeTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>>(AsyncInitializeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>> PrepareAsyncInitialize(::grpc::ClientContext* context, const ::CGData::CGGmeTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>>(PrepareAsyncInitializeRaw(context, request, cq));
    }
    virtual ::grpc::Status Connect(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::CGData::CGBoolData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGBoolData>> AsyncConnect(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGBoolData>>(AsyncConnectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGBoolData>> PrepareAsyncConnect(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGBoolData>>(PrepareAsyncConnectRaw(context, request, cq));
    }
    virtual ::grpc::Status IsInGame(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::CGData::CGIntData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>> AsyncIsInGame(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>>(AsyncIsInGameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>> PrepareAsyncIsInGame(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>>(PrepareAsyncIsInGameRaw(context, request, cq));
    }
    virtual ::grpc::Status GetWorldStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::CGData::CGIntData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>> AsyncGetWorldStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>>(AsyncGetWorldStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>> PrepareAsyncGetWorldStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>>(PrepareAsyncGetWorldStatusRaw(context, request, cq));
    }
    virtual ::grpc::Status GetGameStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::CGData::CGIntData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>> AsyncGetGameStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>>(AsyncGetGameStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>> PrepareAsyncGetGameStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>>(PrepareAsyncGetGameStatusRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBGMIndex(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::CGData::CGIntData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>> AsyncGetBGMIndex(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>>(AsyncGetBGMIndexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>> PrepareAsyncGetBGMIndex(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>>(PrepareAsyncGetBGMIndexRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSysTime(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::CGData::CGSysTimeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGSysTimeResponse>> AsyncGetSysTime(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGSysTimeResponse>>(AsyncGetSysTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGSysTimeResponse>> PrepareAsyncGetSysTime(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGSysTimeResponse>>(PrepareAsyncGetSysTimeRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPlayerInfo(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::CGData::CGCharacterData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGCharacterData>> AsyncGetPlayerInfo(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGCharacterData>>(AsyncGetPlayerInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGCharacterData>> PrepareAsyncGetPlayerInfo(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGCharacterData>>(PrepareAsyncGetPlayerInfoRaw(context, request, cq));
    }
    virtual ::grpc::Status SetPlayerFlagEnabled(::grpc::ClientContext* context, const ::CGData::CGPlayerFlagEnabledData& request, ::CGData::CGVoidData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>> AsyncSetPlayerFlagEnabled(::grpc::ClientContext* context, const ::CGData::CGPlayerFlagEnabledData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>>(AsyncSetPlayerFlagEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>> PrepareAsyncSetPlayerFlagEnabled(::grpc::ClientContext* context, const ::CGData::CGPlayerFlagEnabledData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>>(PrepareAsyncSetPlayerFlagEnabledRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void Initialize(::grpc::ClientContext* context, const ::CGData::CGGmeTypeRequest* request, ::CGData::CGVoidData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Initialize(::grpc::ClientContext* context, const ::CGData::CGGmeTypeRequest* request, ::CGData::CGVoidData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Connect(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGBoolData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Connect(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGBoolData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void IsInGame(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void IsInGame(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetWorldStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetWorldStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetGameStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGameStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetBGMIndex(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBGMIndex(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSysTime(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGSysTimeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSysTime(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGSysTimeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetPlayerInfo(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGCharacterData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPlayerInfo(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGCharacterData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetPlayerFlagEnabled(::grpc::ClientContext* context, const ::CGData::CGPlayerFlagEnabledData* request, ::CGData::CGVoidData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPlayerFlagEnabled(::grpc::ClientContext* context, const ::CGData::CGPlayerFlagEnabledData* request, ::CGData::CGVoidData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>* AsyncInitializeRaw(::grpc::ClientContext* context, const ::CGData::CGGmeTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>* PrepareAsyncInitializeRaw(::grpc::ClientContext* context, const ::CGData::CGGmeTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGBoolData>* AsyncConnectRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGBoolData>* PrepareAsyncConnectRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>* AsyncIsInGameRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>* PrepareAsyncIsInGameRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>* AsyncGetWorldStatusRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>* PrepareAsyncGetWorldStatusRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>* AsyncGetGameStatusRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>* PrepareAsyncGetGameStatusRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>* AsyncGetBGMIndexRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGIntData>* PrepareAsyncGetBGMIndexRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGSysTimeResponse>* AsyncGetSysTimeRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGSysTimeResponse>* PrepareAsyncGetSysTimeRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGCharacterData>* AsyncGetPlayerInfoRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGCharacterData>* PrepareAsyncGetPlayerInfoRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>* AsyncSetPlayerFlagEnabledRaw(::grpc::ClientContext* context, const ::CGData::CGPlayerFlagEnabledData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>* PrepareAsyncSetPlayerFlagEnabledRaw(::grpc::ClientContext* context, const ::CGData::CGPlayerFlagEnabledData& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Initialize(::grpc::ClientContext* context, const ::CGData::CGGmeTypeRequest& request, ::CGData::CGVoidData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>> AsyncInitialize(::grpc::ClientContext* context, const ::CGData::CGGmeTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>>(AsyncInitializeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>> PrepareAsyncInitialize(::grpc::ClientContext* context, const ::CGData::CGGmeTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>>(PrepareAsyncInitializeRaw(context, request, cq));
    }
    ::grpc::Status Connect(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::CGData::CGBoolData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGBoolData>> AsyncConnect(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGBoolData>>(AsyncConnectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGBoolData>> PrepareAsyncConnect(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGBoolData>>(PrepareAsyncConnectRaw(context, request, cq));
    }
    ::grpc::Status IsInGame(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::CGData::CGIntData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>> AsyncIsInGame(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>>(AsyncIsInGameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>> PrepareAsyncIsInGame(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>>(PrepareAsyncIsInGameRaw(context, request, cq));
    }
    ::grpc::Status GetWorldStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::CGData::CGIntData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>> AsyncGetWorldStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>>(AsyncGetWorldStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>> PrepareAsyncGetWorldStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>>(PrepareAsyncGetWorldStatusRaw(context, request, cq));
    }
    ::grpc::Status GetGameStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::CGData::CGIntData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>> AsyncGetGameStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>>(AsyncGetGameStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>> PrepareAsyncGetGameStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>>(PrepareAsyncGetGameStatusRaw(context, request, cq));
    }
    ::grpc::Status GetBGMIndex(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::CGData::CGIntData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>> AsyncGetBGMIndex(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>>(AsyncGetBGMIndexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>> PrepareAsyncGetBGMIndex(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>>(PrepareAsyncGetBGMIndexRaw(context, request, cq));
    }
    ::grpc::Status GetSysTime(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::CGData::CGSysTimeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGSysTimeResponse>> AsyncGetSysTime(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGSysTimeResponse>>(AsyncGetSysTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGSysTimeResponse>> PrepareAsyncGetSysTime(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGSysTimeResponse>>(PrepareAsyncGetSysTimeRaw(context, request, cq));
    }
    ::grpc::Status GetPlayerInfo(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::CGData::CGCharacterData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGCharacterData>> AsyncGetPlayerInfo(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGCharacterData>>(AsyncGetPlayerInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGCharacterData>> PrepareAsyncGetPlayerInfo(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGCharacterData>>(PrepareAsyncGetPlayerInfoRaw(context, request, cq));
    }
    ::grpc::Status SetPlayerFlagEnabled(::grpc::ClientContext* context, const ::CGData::CGPlayerFlagEnabledData& request, ::CGData::CGVoidData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>> AsyncSetPlayerFlagEnabled(::grpc::ClientContext* context, const ::CGData::CGPlayerFlagEnabledData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>>(AsyncSetPlayerFlagEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>> PrepareAsyncSetPlayerFlagEnabled(::grpc::ClientContext* context, const ::CGData::CGPlayerFlagEnabledData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>>(PrepareAsyncSetPlayerFlagEnabledRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Initialize(::grpc::ClientContext* context, const ::CGData::CGGmeTypeRequest* request, ::CGData::CGVoidData* response, std::function<void(::grpc::Status)>) override;
      void Initialize(::grpc::ClientContext* context, const ::CGData::CGGmeTypeRequest* request, ::CGData::CGVoidData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Connect(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGBoolData* response, std::function<void(::grpc::Status)>) override;
      void Connect(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGBoolData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void IsInGame(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response, std::function<void(::grpc::Status)>) override;
      void IsInGame(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetWorldStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response, std::function<void(::grpc::Status)>) override;
      void GetWorldStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetGameStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response, std::function<void(::grpc::Status)>) override;
      void GetGameStatus(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetBGMIndex(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response, std::function<void(::grpc::Status)>) override;
      void GetBGMIndex(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSysTime(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGSysTimeResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSysTime(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGSysTimeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPlayerInfo(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGCharacterData* response, std::function<void(::grpc::Status)>) override;
      void GetPlayerInfo(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGCharacterData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetPlayerFlagEnabled(::grpc::ClientContext* context, const ::CGData::CGPlayerFlagEnabledData* request, ::CGData::CGVoidData* response, std::function<void(::grpc::Status)>) override;
      void SetPlayerFlagEnabled(::grpc::ClientContext* context, const ::CGData::CGPlayerFlagEnabledData* request, ::CGData::CGVoidData* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>* AsyncInitializeRaw(::grpc::ClientContext* context, const ::CGData::CGGmeTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>* PrepareAsyncInitializeRaw(::grpc::ClientContext* context, const ::CGData::CGGmeTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGBoolData>* AsyncConnectRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGBoolData>* PrepareAsyncConnectRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>* AsyncIsInGameRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>* PrepareAsyncIsInGameRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>* AsyncGetWorldStatusRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>* PrepareAsyncGetWorldStatusRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>* AsyncGetGameStatusRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>* PrepareAsyncGetGameStatusRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>* AsyncGetBGMIndexRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGIntData>* PrepareAsyncGetBGMIndexRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGSysTimeResponse>* AsyncGetSysTimeRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGSysTimeResponse>* PrepareAsyncGetSysTimeRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGCharacterData>* AsyncGetPlayerInfoRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGCharacterData>* PrepareAsyncGetPlayerInfoRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>* AsyncSetPlayerFlagEnabledRaw(::grpc::ClientContext* context, const ::CGData::CGPlayerFlagEnabledData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>* PrepareAsyncSetPlayerFlagEnabledRaw(::grpc::ClientContext* context, const ::CGData::CGPlayerFlagEnabledData& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Initialize_;
    const ::grpc::internal::RpcMethod rpcmethod_Connect_;
    const ::grpc::internal::RpcMethod rpcmethod_IsInGame_;
    const ::grpc::internal::RpcMethod rpcmethod_GetWorldStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGameStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBGMIndex_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSysTime_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPlayerInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_SetPlayerFlagEnabled_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Initialize(::grpc::ServerContext* context, const ::CGData::CGGmeTypeRequest* request, ::CGData::CGVoidData* response);
    virtual ::grpc::Status Connect(::grpc::ServerContext* context, const ::CGData::CGVoidData* request, ::CGData::CGBoolData* response);
    virtual ::grpc::Status IsInGame(::grpc::ServerContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response);
    virtual ::grpc::Status GetWorldStatus(::grpc::ServerContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response);
    virtual ::grpc::Status GetGameStatus(::grpc::ServerContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response);
    virtual ::grpc::Status GetBGMIndex(::grpc::ServerContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response);
    virtual ::grpc::Status GetSysTime(::grpc::ServerContext* context, const ::CGData::CGVoidData* request, ::CGData::CGSysTimeResponse* response);
    virtual ::grpc::Status GetPlayerInfo(::grpc::ServerContext* context, const ::CGData::CGVoidData* request, ::CGData::CGCharacterData* response);
    virtual ::grpc::Status SetPlayerFlagEnabled(::grpc::ServerContext* context, const ::CGData::CGPlayerFlagEnabledData* request, ::CGData::CGVoidData* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Initialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Initialize() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Initialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Initialize(::grpc::ServerContext* /*context*/, const ::CGData::CGGmeTypeRequest* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInitialize(::grpc::ServerContext* context, ::CGData::CGGmeTypeRequest* request, ::grpc::ServerAsyncResponseWriter< ::CGData::CGVoidData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Connect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Connect() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Connect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connect(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGBoolData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnect(::grpc::ServerContext* context, ::CGData::CGVoidData* request, ::grpc::ServerAsyncResponseWriter< ::CGData::CGBoolData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsInGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IsInGame() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_IsInGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsInGame(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsInGame(::grpc::ServerContext* context, ::CGData::CGVoidData* request, ::grpc::ServerAsyncResponseWriter< ::CGData::CGIntData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetWorldStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetWorldStatus() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetWorldStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorldStatus(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorldStatus(::grpc::ServerContext* context, ::CGData::CGVoidData* request, ::grpc::ServerAsyncResponseWriter< ::CGData::CGIntData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGameStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetGameStatus() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetGameStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGameStatus(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGameStatus(::grpc::ServerContext* context, ::CGData::CGVoidData* request, ::grpc::ServerAsyncResponseWriter< ::CGData::CGIntData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBGMIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBGMIndex() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetBGMIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBGMIndex(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBGMIndex(::grpc::ServerContext* context, ::CGData::CGVoidData* request, ::grpc::ServerAsyncResponseWriter< ::CGData::CGIntData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSysTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSysTime() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetSysTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSysTime(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGSysTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSysTime(::grpc::ServerContext* context, ::CGData::CGVoidData* request, ::grpc::ServerAsyncResponseWriter< ::CGData::CGSysTimeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPlayerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPlayerInfo() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetPlayerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerInfo(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGCharacterData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayerInfo(::grpc::ServerContext* context, ::CGData::CGVoidData* request, ::grpc::ServerAsyncResponseWriter< ::CGData::CGCharacterData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPlayerFlagEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetPlayerFlagEnabled() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SetPlayerFlagEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayerFlagEnabled(::grpc::ServerContext* /*context*/, const ::CGData::CGPlayerFlagEnabledData* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPlayerFlagEnabled(::grpc::ServerContext* context, ::CGData::CGPlayerFlagEnabledData* request, ::grpc::ServerAsyncResponseWriter< ::CGData::CGVoidData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Initialize<WithAsyncMethod_Connect<WithAsyncMethod_IsInGame<WithAsyncMethod_GetWorldStatus<WithAsyncMethod_GetGameStatus<WithAsyncMethod_GetBGMIndex<WithAsyncMethod_GetSysTime<WithAsyncMethod_GetPlayerInfo<WithAsyncMethod_SetPlayerFlagEnabled<Service > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Initialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Initialize() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::CGGmeTypeRequest, ::CGData::CGVoidData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::CGGmeTypeRequest* request, ::CGData::CGVoidData* response) { return this->Initialize(context, request, response); }));}
    void SetMessageAllocatorFor_Initialize(
        ::grpc::MessageAllocator< ::CGData::CGGmeTypeRequest, ::CGData::CGVoidData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::CGGmeTypeRequest, ::CGData::CGVoidData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Initialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Initialize(::grpc::ServerContext* /*context*/, const ::CGData::CGGmeTypeRequest* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Initialize(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::CGGmeTypeRequest* /*request*/, ::CGData::CGVoidData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Connect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Connect() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::CGVoidData, ::CGData::CGBoolData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::CGVoidData* request, ::CGData::CGBoolData* response) { return this->Connect(context, request, response); }));}
    void SetMessageAllocatorFor_Connect(
        ::grpc::MessageAllocator< ::CGData::CGVoidData, ::CGData::CGBoolData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::CGVoidData, ::CGData::CGBoolData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Connect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connect(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGBoolData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Connect(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGBoolData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_IsInGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_IsInGame() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::CGVoidData, ::CGData::CGIntData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response) { return this->IsInGame(context, request, response); }));}
    void SetMessageAllocatorFor_IsInGame(
        ::grpc::MessageAllocator< ::CGData::CGVoidData, ::CGData::CGIntData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::CGVoidData, ::CGData::CGIntData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_IsInGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsInGame(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsInGame(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetWorldStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetWorldStatus() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::CGVoidData, ::CGData::CGIntData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response) { return this->GetWorldStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetWorldStatus(
        ::grpc::MessageAllocator< ::CGData::CGVoidData, ::CGData::CGIntData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::CGVoidData, ::CGData::CGIntData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetWorldStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorldStatus(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetWorldStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetGameStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetGameStatus() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::CGVoidData, ::CGData::CGIntData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response) { return this->GetGameStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetGameStatus(
        ::grpc::MessageAllocator< ::CGData::CGVoidData, ::CGData::CGIntData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::CGVoidData, ::CGData::CGIntData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetGameStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGameStatus(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGameStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetBGMIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetBGMIndex() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::CGVoidData, ::CGData::CGIntData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::CGVoidData* request, ::CGData::CGIntData* response) { return this->GetBGMIndex(context, request, response); }));}
    void SetMessageAllocatorFor_GetBGMIndex(
        ::grpc::MessageAllocator< ::CGData::CGVoidData, ::CGData::CGIntData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::CGVoidData, ::CGData::CGIntData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetBGMIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBGMIndex(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBGMIndex(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSysTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSysTime() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::CGVoidData, ::CGData::CGSysTimeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::CGVoidData* request, ::CGData::CGSysTimeResponse* response) { return this->GetSysTime(context, request, response); }));}
    void SetMessageAllocatorFor_GetSysTime(
        ::grpc::MessageAllocator< ::CGData::CGVoidData, ::CGData::CGSysTimeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::CGVoidData, ::CGData::CGSysTimeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSysTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSysTime(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGSysTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSysTime(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGSysTimeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPlayerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPlayerInfo() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::CGVoidData, ::CGData::CGCharacterData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::CGVoidData* request, ::CGData::CGCharacterData* response) { return this->GetPlayerInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetPlayerInfo(
        ::grpc::MessageAllocator< ::CGData::CGVoidData, ::CGData::CGCharacterData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::CGVoidData, ::CGData::CGCharacterData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPlayerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerInfo(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGCharacterData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPlayerInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGCharacterData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetPlayerFlagEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetPlayerFlagEnabled() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::CGPlayerFlagEnabledData, ::CGData::CGVoidData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::CGPlayerFlagEnabledData* request, ::CGData::CGVoidData* response) { return this->SetPlayerFlagEnabled(context, request, response); }));}
    void SetMessageAllocatorFor_SetPlayerFlagEnabled(
        ::grpc::MessageAllocator< ::CGData::CGPlayerFlagEnabledData, ::CGData::CGVoidData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::CGPlayerFlagEnabledData, ::CGData::CGVoidData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetPlayerFlagEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayerFlagEnabled(::grpc::ServerContext* /*context*/, const ::CGData::CGPlayerFlagEnabledData* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPlayerFlagEnabled(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::CGPlayerFlagEnabledData* /*request*/, ::CGData::CGVoidData* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Initialize<WithCallbackMethod_Connect<WithCallbackMethod_IsInGame<WithCallbackMethod_GetWorldStatus<WithCallbackMethod_GetGameStatus<WithCallbackMethod_GetBGMIndex<WithCallbackMethod_GetSysTime<WithCallbackMethod_GetPlayerInfo<WithCallbackMethod_SetPlayerFlagEnabled<Service > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Initialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Initialize() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Initialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Initialize(::grpc::ServerContext* /*context*/, const ::CGData::CGGmeTypeRequest* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Connect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Connect() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Connect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connect(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGBoolData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsInGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IsInGame() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_IsInGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsInGame(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetWorldStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetWorldStatus() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetWorldStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorldStatus(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGameStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetGameStatus() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetGameStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGameStatus(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBGMIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBGMIndex() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetBGMIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBGMIndex(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSysTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSysTime() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetSysTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSysTime(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGSysTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPlayerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPlayerInfo() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetPlayerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerInfo(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGCharacterData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetPlayerFlagEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetPlayerFlagEnabled() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SetPlayerFlagEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayerFlagEnabled(::grpc::ServerContext* /*context*/, const ::CGData::CGPlayerFlagEnabledData* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Initialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Initialize() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Initialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Initialize(::grpc::ServerContext* /*context*/, const ::CGData::CGGmeTypeRequest* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInitialize(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Connect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Connect() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Connect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connect(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGBoolData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnect(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsInGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IsInGame() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_IsInGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsInGame(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsInGame(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetWorldStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetWorldStatus() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetWorldStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorldStatus(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorldStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGameStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetGameStatus() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetGameStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGameStatus(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGameStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBGMIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBGMIndex() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetBGMIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBGMIndex(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBGMIndex(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSysTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSysTime() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetSysTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSysTime(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGSysTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSysTime(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPlayerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPlayerInfo() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetPlayerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerInfo(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGCharacterData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayerInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPlayerFlagEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetPlayerFlagEnabled() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_SetPlayerFlagEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayerFlagEnabled(::grpc::ServerContext* /*context*/, const ::CGData::CGPlayerFlagEnabledData* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPlayerFlagEnabled(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Initialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Initialize() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Initialize(context, request, response); }));
    }
    ~WithRawCallbackMethod_Initialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Initialize(::grpc::ServerContext* /*context*/, const ::CGData::CGGmeTypeRequest* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Initialize(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Connect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Connect() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Connect(context, request, response); }));
    }
    ~WithRawCallbackMethod_Connect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connect(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGBoolData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Connect(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_IsInGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_IsInGame() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IsInGame(context, request, response); }));
    }
    ~WithRawCallbackMethod_IsInGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsInGame(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsInGame(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetWorldStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetWorldStatus() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetWorldStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetWorldStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorldStatus(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetWorldStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetGameStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetGameStatus() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetGameStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetGameStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGameStatus(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGameStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetBGMIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetBGMIndex() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBGMIndex(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetBGMIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBGMIndex(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBGMIndex(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSysTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSysTime() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSysTime(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSysTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSysTime(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGSysTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSysTime(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPlayerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPlayerInfo() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPlayerInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPlayerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerInfo(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGCharacterData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPlayerInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetPlayerFlagEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetPlayerFlagEnabled() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetPlayerFlagEnabled(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetPlayerFlagEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayerFlagEnabled(::grpc::ServerContext* /*context*/, const ::CGData::CGPlayerFlagEnabledData* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPlayerFlagEnabled(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Initialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Initialize() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::CGGmeTypeRequest, ::CGData::CGVoidData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::CGGmeTypeRequest, ::CGData::CGVoidData>* streamer) {
                       return this->StreamedInitialize(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Initialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Initialize(::grpc::ServerContext* /*context*/, const ::CGData::CGGmeTypeRequest* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInitialize(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::CGGmeTypeRequest,::CGData::CGVoidData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Connect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Connect() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::CGVoidData, ::CGData::CGBoolData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::CGVoidData, ::CGData::CGBoolData>* streamer) {
                       return this->StreamedConnect(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Connect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Connect(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGBoolData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConnect(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::CGVoidData,::CGData::CGBoolData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsInGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IsInGame() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::CGVoidData, ::CGData::CGIntData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::CGVoidData, ::CGData::CGIntData>* streamer) {
                       return this->StreamedIsInGame(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IsInGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsInGame(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsInGame(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::CGVoidData,::CGData::CGIntData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetWorldStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetWorldStatus() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::CGVoidData, ::CGData::CGIntData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::CGVoidData, ::CGData::CGIntData>* streamer) {
                       return this->StreamedGetWorldStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetWorldStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetWorldStatus(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetWorldStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::CGVoidData,::CGData::CGIntData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetGameStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetGameStatus() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::CGVoidData, ::CGData::CGIntData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::CGVoidData, ::CGData::CGIntData>* streamer) {
                       return this->StreamedGetGameStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetGameStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGameStatus(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetGameStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::CGVoidData,::CGData::CGIntData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBGMIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBGMIndex() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::CGVoidData, ::CGData::CGIntData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::CGVoidData, ::CGData::CGIntData>* streamer) {
                       return this->StreamedGetBGMIndex(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBGMIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBGMIndex(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGIntData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBGMIndex(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::CGVoidData,::CGData::CGIntData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSysTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSysTime() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::CGVoidData, ::CGData::CGSysTimeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::CGVoidData, ::CGData::CGSysTimeResponse>* streamer) {
                       return this->StreamedGetSysTime(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSysTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSysTime(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGSysTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSysTime(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::CGVoidData,::CGData::CGSysTimeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPlayerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPlayerInfo() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::CGVoidData, ::CGData::CGCharacterData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::CGVoidData, ::CGData::CGCharacterData>* streamer) {
                       return this->StreamedGetPlayerInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPlayerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPlayerInfo(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGCharacterData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPlayerInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::CGVoidData,::CGData::CGCharacterData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPlayerFlagEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetPlayerFlagEnabled() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::CGPlayerFlagEnabledData, ::CGData::CGVoidData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::CGPlayerFlagEnabledData, ::CGData::CGVoidData>* streamer) {
                       return this->StreamedSetPlayerFlagEnabled(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetPlayerFlagEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPlayerFlagEnabled(::grpc::ServerContext* /*context*/, const ::CGData::CGPlayerFlagEnabledData* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPlayerFlagEnabled(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::CGPlayerFlagEnabledData,::CGData::CGVoidData>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Initialize<WithStreamedUnaryMethod_Connect<WithStreamedUnaryMethod_IsInGame<WithStreamedUnaryMethod_GetWorldStatus<WithStreamedUnaryMethod_GetGameStatus<WithStreamedUnaryMethod_GetBGMIndex<WithStreamedUnaryMethod_GetSysTime<WithStreamedUnaryMethod_GetPlayerInfo<WithStreamedUnaryMethod_SetPlayerFlagEnabled<Service > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Initialize<WithStreamedUnaryMethod_Connect<WithStreamedUnaryMethod_IsInGame<WithStreamedUnaryMethod_GetWorldStatus<WithStreamedUnaryMethod_GetGameStatus<WithStreamedUnaryMethod_GetBGMIndex<WithStreamedUnaryMethod_GetSysTime<WithStreamedUnaryMethod_GetPlayerInfo<WithStreamedUnaryMethod_SetPlayerFlagEnabled<Service > > > > > > > > > StreamedService;
};

// 辅助和服务端通信用
class CGRpcService final {
 public:
  static constexpr char const* service_full_name() {
    return "CGData.CGRpcService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // 根据item的id，获取item信息
    virtual ::grpc::Status GetCGItemData(::grpc::ClientContext* context, const ::CGData::CGItemRequest& request, ::CGData::CGItemResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGItemResponse>> AsyncGetCGItemData(::grpc::ClientContext* context, const ::CGData::CGItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGItemResponse>>(AsyncGetCGItemDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGItemResponse>> PrepareAsyncGetCGItemData(::grpc::ClientContext* context, const ::CGData::CGItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGItemResponse>>(PrepareAsyncGetCGItemDataRaw(context, request, cq));
    }
    virtual ::grpc::Status GetConnectState(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::CGData::CGVoidData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>> AsyncGetConnectState(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>>(AsyncGetConnectStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>> PrepareAsyncGetConnectState(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>>(PrepareAsyncGetConnectStateRaw(context, request, cq));
    }
    // 获取所有宠物算档数据
    virtual ::grpc::Status GetPetGradeCalcData(::grpc::ClientContext* context, const ::CGData::CGPetGradeCalcRequest& request, ::CGData::CGPetGradeCalcResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGPetGradeCalcResponse>> AsyncGetPetGradeCalcData(::grpc::ClientContext* context, const ::CGData::CGPetGradeCalcRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGPetGradeCalcResponse>>(AsyncGetPetGradeCalcDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGPetGradeCalcResponse>> PrepareAsyncGetPetGradeCalcData(::grpc::ClientContext* context, const ::CGData::CGPetGradeCalcRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGPetGradeCalcResponse>>(PrepareAsyncGetPetGradeCalcDataRaw(context, request, cq));
    }
    // 获取服务端所有id和map名称的映射，用于本地缓存
    virtual ::grpc::Status GetServerStoreMapData(::grpc::ClientContext* context, const ::CGData::CGMapDataRequest& request, ::CGData::CGMapDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGMapDataResponse>> AsyncGetServerStoreMapData(::grpc::ClientContext* context, const ::CGData::CGMapDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGMapDataResponse>>(AsyncGetServerStoreMapDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGMapDataResponse>> PrepareAsyncGetServerStoreMapData(::grpc::ClientContext* context, const ::CGData::CGMapDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGMapDataResponse>>(PrepareAsyncGetServerStoreMapDataRaw(context, request, cq));
    }
    // 客户端向服务器发送当前包裹物品信息，服务端用于缓存和更新数据库
    virtual ::grpc::Status StoreCGItemData(::grpc::ClientContext* context, const ::CGData::CGStoreItemRequest& request, ::CGData::CGStoreItemResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGStoreItemResponse>> AsyncStoreCGItemData(::grpc::ClientContext* context, const ::CGData::CGStoreItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGStoreItemResponse>>(AsyncStoreCGItemDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGStoreItemResponse>> PrepareAsyncStoreCGItemData(::grpc::ClientContext* context, const ::CGData::CGStoreItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGStoreItemResponse>>(PrepareAsyncStoreCGItemDataRaw(context, request, cq));
    }
    // 客户端向服务器发送地图信息，服务端缓存更新
    virtual ::grpc::Status StoreCGMapData(::grpc::ClientContext* context, const ::CGData::CGStoreMapRequest& request, ::CGData::CGStoreMapResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGStoreMapResponse>> AsyncStoreCGMapData(::grpc::ClientContext* context, const ::CGData::CGStoreMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGStoreMapResponse>>(AsyncStoreCGMapDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGStoreMapResponse>> PrepareAsyncStoreCGMapData(::grpc::ClientContext* context, const ::CGData::CGStoreMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGStoreMapResponse>>(PrepareAsyncStoreCGMapDataRaw(context, request, cq));
    }
    // 定时上报当辅助信息
    virtual ::grpc::Status UploadGidData(::grpc::ClientContext* context, const ::CGData::UploadGidDataRequest& request, ::CGData::UploadGidDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::UploadGidDataResponse>> AsyncUploadGidData(::grpc::ClientContext* context, const ::CGData::UploadGidDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::UploadGidDataResponse>>(AsyncUploadGidDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::UploadGidDataResponse>> PrepareAsyncUploadGidData(::grpc::ClientContext* context, const ::CGData::UploadGidDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::UploadGidDataResponse>>(PrepareAsyncUploadGidDataRaw(context, request, cq));
    }
    virtual ::grpc::Status UploadGidBankData(::grpc::ClientContext* context, const ::CGData::UploadGidBankDataRequest& request, ::CGData::UploadGidBankDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::UploadGidBankDataResponse>> AsyncUploadGidBankData(::grpc::ClientContext* context, const ::CGData::UploadGidBankDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::UploadGidBankDataResponse>>(AsyncUploadGidBankDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::UploadGidBankDataResponse>> PrepareAsyncUploadGidBankData(::grpc::ClientContext* context, const ::CGData::UploadGidBankDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::UploadGidBankDataResponse>>(PrepareAsyncUploadGidBankDataRaw(context, request, cq));
    }
    // 发布是rpc的普通方法
    virtual ::grpc::Status Publish(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::CGData::StringPub* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::StringPub>> AsyncPublish(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::StringPub>>(AsyncPublishRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::StringPub>> PrepareAsyncPublish(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::StringPub>>(PrepareAsyncPublishRaw(context, request, cq));
    }
    // 订阅则是一个单向的流服务，服务端返回的数据可能很大
    std::unique_ptr< ::grpc::ClientReaderInterface< ::CGData::StringPub>> Subscribe(::grpc::ClientContext* context, const ::CGData::StringPub& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::CGData::StringPub>>(SubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::CGData::StringPub>> AsyncSubscribe(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::CGData::StringPub>>(AsyncSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::CGData::StringPub>> PrepareAsyncSubscribe(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::CGData::StringPub>>(PrepareAsyncSubscribeRaw(context, request, cq));
    }
    // *****************客户端查询数据接口*************
    //
    // 查询指定账号下各GID的角色数据
    virtual ::grpc::Status SelectAccountGidData(::grpc::ClientContext* context, const ::CGData::SelectAccountGidDataRequest& request, ::CGData::SelectAccountGidDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectAccountGidDataResponse>> AsyncSelectAccountGidData(::grpc::ClientContext* context, const ::CGData::SelectAccountGidDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectAccountGidDataResponse>>(AsyncSelectAccountGidDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectAccountGidDataResponse>> PrepareAsyncSelectAccountGidData(::grpc::ClientContext* context, const ::CGData::SelectAccountGidDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectAccountGidDataResponse>>(PrepareAsyncSelectAccountGidDataRaw(context, request, cq));
    }
    virtual ::grpc::Status SelectGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::CGData::SelectGidDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectGidDataResponse>> AsyncSelectGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectGidDataResponse>>(AsyncSelectGidDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectGidDataResponse>> PrepareAsyncSelectGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectGidDataResponse>>(PrepareAsyncSelectGidDataRaw(context, request, cq));
    }
    // 查询指定类型的gid角色数据 例如：当前gid是哥布林仓库专用，则查询所有此类型账号 一个角色可以是全部类型
    virtual ::grpc::Status SelectDstTypeGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::CGData::SelectAccountGidDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectAccountGidDataResponse>> AsyncSelectDstTypeGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectAccountGidDataResponse>>(AsyncSelectDstTypeGidDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectAccountGidDataResponse>> PrepareAsyncSelectDstTypeGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectAccountGidDataResponse>>(PrepareAsyncSelectDstTypeGidDataRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // 根据item的id，获取item信息
      virtual void GetCGItemData(::grpc::ClientContext* context, const ::CGData::CGItemRequest* request, ::CGData::CGItemResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCGItemData(::grpc::ClientContext* context, const ::CGData::CGItemRequest* request, ::CGData::CGItemResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetConnectState(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGVoidData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetConnectState(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGVoidData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 获取所有宠物算档数据
      virtual void GetPetGradeCalcData(::grpc::ClientContext* context, const ::CGData::CGPetGradeCalcRequest* request, ::CGData::CGPetGradeCalcResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPetGradeCalcData(::grpc::ClientContext* context, const ::CGData::CGPetGradeCalcRequest* request, ::CGData::CGPetGradeCalcResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 获取服务端所有id和map名称的映射，用于本地缓存
      virtual void GetServerStoreMapData(::grpc::ClientContext* context, const ::CGData::CGMapDataRequest* request, ::CGData::CGMapDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetServerStoreMapData(::grpc::ClientContext* context, const ::CGData::CGMapDataRequest* request, ::CGData::CGMapDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 客户端向服务器发送当前包裹物品信息，服务端用于缓存和更新数据库
      virtual void StoreCGItemData(::grpc::ClientContext* context, const ::CGData::CGStoreItemRequest* request, ::CGData::CGStoreItemResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreCGItemData(::grpc::ClientContext* context, const ::CGData::CGStoreItemRequest* request, ::CGData::CGStoreItemResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 客户端向服务器发送地图信息，服务端缓存更新
      virtual void StoreCGMapData(::grpc::ClientContext* context, const ::CGData::CGStoreMapRequest* request, ::CGData::CGStoreMapResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreCGMapData(::grpc::ClientContext* context, const ::CGData::CGStoreMapRequest* request, ::CGData::CGStoreMapResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 定时上报当辅助信息
      virtual void UploadGidData(::grpc::ClientContext* context, const ::CGData::UploadGidDataRequest* request, ::CGData::UploadGidDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UploadGidData(::grpc::ClientContext* context, const ::CGData::UploadGidDataRequest* request, ::CGData::UploadGidDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void UploadGidBankData(::grpc::ClientContext* context, const ::CGData::UploadGidBankDataRequest* request, ::CGData::UploadGidBankDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UploadGidBankData(::grpc::ClientContext* context, const ::CGData::UploadGidBankDataRequest* request, ::CGData::UploadGidBankDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 发布是rpc的普通方法
      virtual void Publish(::grpc::ClientContext* context, const ::CGData::StringPub* request, ::CGData::StringPub* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Publish(::grpc::ClientContext* context, const ::CGData::StringPub* request, ::CGData::StringPub* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 订阅则是一个单向的流服务，服务端返回的数据可能很大
      virtual void Subscribe(::grpc::ClientContext* context, const ::CGData::StringPub* request, ::grpc::ClientReadReactor< ::CGData::StringPub>* reactor) = 0;
      // *****************客户端查询数据接口*************
      //
      // 查询指定账号下各GID的角色数据
      virtual void SelectAccountGidData(::grpc::ClientContext* context, const ::CGData::SelectAccountGidDataRequest* request, ::CGData::SelectAccountGidDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SelectAccountGidData(::grpc::ClientContext* context, const ::CGData::SelectAccountGidDataRequest* request, ::CGData::SelectAccountGidDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SelectGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest* request, ::CGData::SelectGidDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SelectGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest* request, ::CGData::SelectGidDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 查询指定类型的gid角色数据 例如：当前gid是哥布林仓库专用，则查询所有此类型账号 一个角色可以是全部类型
      virtual void SelectDstTypeGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest* request, ::CGData::SelectAccountGidDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SelectDstTypeGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest* request, ::CGData::SelectAccountGidDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGItemResponse>* AsyncGetCGItemDataRaw(::grpc::ClientContext* context, const ::CGData::CGItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGItemResponse>* PrepareAsyncGetCGItemDataRaw(::grpc::ClientContext* context, const ::CGData::CGItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>* AsyncGetConnectStateRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGVoidData>* PrepareAsyncGetConnectStateRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGPetGradeCalcResponse>* AsyncGetPetGradeCalcDataRaw(::grpc::ClientContext* context, const ::CGData::CGPetGradeCalcRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGPetGradeCalcResponse>* PrepareAsyncGetPetGradeCalcDataRaw(::grpc::ClientContext* context, const ::CGData::CGPetGradeCalcRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGMapDataResponse>* AsyncGetServerStoreMapDataRaw(::grpc::ClientContext* context, const ::CGData::CGMapDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGMapDataResponse>* PrepareAsyncGetServerStoreMapDataRaw(::grpc::ClientContext* context, const ::CGData::CGMapDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGStoreItemResponse>* AsyncStoreCGItemDataRaw(::grpc::ClientContext* context, const ::CGData::CGStoreItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGStoreItemResponse>* PrepareAsyncStoreCGItemDataRaw(::grpc::ClientContext* context, const ::CGData::CGStoreItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGStoreMapResponse>* AsyncStoreCGMapDataRaw(::grpc::ClientContext* context, const ::CGData::CGStoreMapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::CGStoreMapResponse>* PrepareAsyncStoreCGMapDataRaw(::grpc::ClientContext* context, const ::CGData::CGStoreMapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::UploadGidDataResponse>* AsyncUploadGidDataRaw(::grpc::ClientContext* context, const ::CGData::UploadGidDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::UploadGidDataResponse>* PrepareAsyncUploadGidDataRaw(::grpc::ClientContext* context, const ::CGData::UploadGidDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::UploadGidBankDataResponse>* AsyncUploadGidBankDataRaw(::grpc::ClientContext* context, const ::CGData::UploadGidBankDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::UploadGidBankDataResponse>* PrepareAsyncUploadGidBankDataRaw(::grpc::ClientContext* context, const ::CGData::UploadGidBankDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::StringPub>* AsyncPublishRaw(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::StringPub>* PrepareAsyncPublishRaw(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::CGData::StringPub>* SubscribeRaw(::grpc::ClientContext* context, const ::CGData::StringPub& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::CGData::StringPub>* AsyncSubscribeRaw(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::CGData::StringPub>* PrepareAsyncSubscribeRaw(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectAccountGidDataResponse>* AsyncSelectAccountGidDataRaw(::grpc::ClientContext* context, const ::CGData::SelectAccountGidDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectAccountGidDataResponse>* PrepareAsyncSelectAccountGidDataRaw(::grpc::ClientContext* context, const ::CGData::SelectAccountGidDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectGidDataResponse>* AsyncSelectGidDataRaw(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectGidDataResponse>* PrepareAsyncSelectGidDataRaw(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectAccountGidDataResponse>* AsyncSelectDstTypeGidDataRaw(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CGData::SelectAccountGidDataResponse>* PrepareAsyncSelectDstTypeGidDataRaw(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetCGItemData(::grpc::ClientContext* context, const ::CGData::CGItemRequest& request, ::CGData::CGItemResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGItemResponse>> AsyncGetCGItemData(::grpc::ClientContext* context, const ::CGData::CGItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGItemResponse>>(AsyncGetCGItemDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGItemResponse>> PrepareAsyncGetCGItemData(::grpc::ClientContext* context, const ::CGData::CGItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGItemResponse>>(PrepareAsyncGetCGItemDataRaw(context, request, cq));
    }
    ::grpc::Status GetConnectState(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::CGData::CGVoidData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>> AsyncGetConnectState(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>>(AsyncGetConnectStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>> PrepareAsyncGetConnectState(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>>(PrepareAsyncGetConnectStateRaw(context, request, cq));
    }
    ::grpc::Status GetPetGradeCalcData(::grpc::ClientContext* context, const ::CGData::CGPetGradeCalcRequest& request, ::CGData::CGPetGradeCalcResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGPetGradeCalcResponse>> AsyncGetPetGradeCalcData(::grpc::ClientContext* context, const ::CGData::CGPetGradeCalcRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGPetGradeCalcResponse>>(AsyncGetPetGradeCalcDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGPetGradeCalcResponse>> PrepareAsyncGetPetGradeCalcData(::grpc::ClientContext* context, const ::CGData::CGPetGradeCalcRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGPetGradeCalcResponse>>(PrepareAsyncGetPetGradeCalcDataRaw(context, request, cq));
    }
    ::grpc::Status GetServerStoreMapData(::grpc::ClientContext* context, const ::CGData::CGMapDataRequest& request, ::CGData::CGMapDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGMapDataResponse>> AsyncGetServerStoreMapData(::grpc::ClientContext* context, const ::CGData::CGMapDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGMapDataResponse>>(AsyncGetServerStoreMapDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGMapDataResponse>> PrepareAsyncGetServerStoreMapData(::grpc::ClientContext* context, const ::CGData::CGMapDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGMapDataResponse>>(PrepareAsyncGetServerStoreMapDataRaw(context, request, cq));
    }
    ::grpc::Status StoreCGItemData(::grpc::ClientContext* context, const ::CGData::CGStoreItemRequest& request, ::CGData::CGStoreItemResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGStoreItemResponse>> AsyncStoreCGItemData(::grpc::ClientContext* context, const ::CGData::CGStoreItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGStoreItemResponse>>(AsyncStoreCGItemDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGStoreItemResponse>> PrepareAsyncStoreCGItemData(::grpc::ClientContext* context, const ::CGData::CGStoreItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGStoreItemResponse>>(PrepareAsyncStoreCGItemDataRaw(context, request, cq));
    }
    ::grpc::Status StoreCGMapData(::grpc::ClientContext* context, const ::CGData::CGStoreMapRequest& request, ::CGData::CGStoreMapResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGStoreMapResponse>> AsyncStoreCGMapData(::grpc::ClientContext* context, const ::CGData::CGStoreMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGStoreMapResponse>>(AsyncStoreCGMapDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGStoreMapResponse>> PrepareAsyncStoreCGMapData(::grpc::ClientContext* context, const ::CGData::CGStoreMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::CGStoreMapResponse>>(PrepareAsyncStoreCGMapDataRaw(context, request, cq));
    }
    ::grpc::Status UploadGidData(::grpc::ClientContext* context, const ::CGData::UploadGidDataRequest& request, ::CGData::UploadGidDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::UploadGidDataResponse>> AsyncUploadGidData(::grpc::ClientContext* context, const ::CGData::UploadGidDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::UploadGidDataResponse>>(AsyncUploadGidDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::UploadGidDataResponse>> PrepareAsyncUploadGidData(::grpc::ClientContext* context, const ::CGData::UploadGidDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::UploadGidDataResponse>>(PrepareAsyncUploadGidDataRaw(context, request, cq));
    }
    ::grpc::Status UploadGidBankData(::grpc::ClientContext* context, const ::CGData::UploadGidBankDataRequest& request, ::CGData::UploadGidBankDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::UploadGidBankDataResponse>> AsyncUploadGidBankData(::grpc::ClientContext* context, const ::CGData::UploadGidBankDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::UploadGidBankDataResponse>>(AsyncUploadGidBankDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::UploadGidBankDataResponse>> PrepareAsyncUploadGidBankData(::grpc::ClientContext* context, const ::CGData::UploadGidBankDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::UploadGidBankDataResponse>>(PrepareAsyncUploadGidBankDataRaw(context, request, cq));
    }
    ::grpc::Status Publish(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::CGData::StringPub* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::StringPub>> AsyncPublish(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::StringPub>>(AsyncPublishRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::StringPub>> PrepareAsyncPublish(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::StringPub>>(PrepareAsyncPublishRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::CGData::StringPub>> Subscribe(::grpc::ClientContext* context, const ::CGData::StringPub& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::CGData::StringPub>>(SubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::CGData::StringPub>> AsyncSubscribe(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::CGData::StringPub>>(AsyncSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::CGData::StringPub>> PrepareAsyncSubscribe(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::CGData::StringPub>>(PrepareAsyncSubscribeRaw(context, request, cq));
    }
    ::grpc::Status SelectAccountGidData(::grpc::ClientContext* context, const ::CGData::SelectAccountGidDataRequest& request, ::CGData::SelectAccountGidDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::SelectAccountGidDataResponse>> AsyncSelectAccountGidData(::grpc::ClientContext* context, const ::CGData::SelectAccountGidDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::SelectAccountGidDataResponse>>(AsyncSelectAccountGidDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::SelectAccountGidDataResponse>> PrepareAsyncSelectAccountGidData(::grpc::ClientContext* context, const ::CGData::SelectAccountGidDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::SelectAccountGidDataResponse>>(PrepareAsyncSelectAccountGidDataRaw(context, request, cq));
    }
    ::grpc::Status SelectGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::CGData::SelectGidDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::SelectGidDataResponse>> AsyncSelectGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::SelectGidDataResponse>>(AsyncSelectGidDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::SelectGidDataResponse>> PrepareAsyncSelectGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::SelectGidDataResponse>>(PrepareAsyncSelectGidDataRaw(context, request, cq));
    }
    ::grpc::Status SelectDstTypeGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::CGData::SelectAccountGidDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::SelectAccountGidDataResponse>> AsyncSelectDstTypeGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::SelectAccountGidDataResponse>>(AsyncSelectDstTypeGidDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::SelectAccountGidDataResponse>> PrepareAsyncSelectDstTypeGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CGData::SelectAccountGidDataResponse>>(PrepareAsyncSelectDstTypeGidDataRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetCGItemData(::grpc::ClientContext* context, const ::CGData::CGItemRequest* request, ::CGData::CGItemResponse* response, std::function<void(::grpc::Status)>) override;
      void GetCGItemData(::grpc::ClientContext* context, const ::CGData::CGItemRequest* request, ::CGData::CGItemResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetConnectState(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGVoidData* response, std::function<void(::grpc::Status)>) override;
      void GetConnectState(::grpc::ClientContext* context, const ::CGData::CGVoidData* request, ::CGData::CGVoidData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPetGradeCalcData(::grpc::ClientContext* context, const ::CGData::CGPetGradeCalcRequest* request, ::CGData::CGPetGradeCalcResponse* response, std::function<void(::grpc::Status)>) override;
      void GetPetGradeCalcData(::grpc::ClientContext* context, const ::CGData::CGPetGradeCalcRequest* request, ::CGData::CGPetGradeCalcResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetServerStoreMapData(::grpc::ClientContext* context, const ::CGData::CGMapDataRequest* request, ::CGData::CGMapDataResponse* response, std::function<void(::grpc::Status)>) override;
      void GetServerStoreMapData(::grpc::ClientContext* context, const ::CGData::CGMapDataRequest* request, ::CGData::CGMapDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StoreCGItemData(::grpc::ClientContext* context, const ::CGData::CGStoreItemRequest* request, ::CGData::CGStoreItemResponse* response, std::function<void(::grpc::Status)>) override;
      void StoreCGItemData(::grpc::ClientContext* context, const ::CGData::CGStoreItemRequest* request, ::CGData::CGStoreItemResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StoreCGMapData(::grpc::ClientContext* context, const ::CGData::CGStoreMapRequest* request, ::CGData::CGStoreMapResponse* response, std::function<void(::grpc::Status)>) override;
      void StoreCGMapData(::grpc::ClientContext* context, const ::CGData::CGStoreMapRequest* request, ::CGData::CGStoreMapResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UploadGidData(::grpc::ClientContext* context, const ::CGData::UploadGidDataRequest* request, ::CGData::UploadGidDataResponse* response, std::function<void(::grpc::Status)>) override;
      void UploadGidData(::grpc::ClientContext* context, const ::CGData::UploadGidDataRequest* request, ::CGData::UploadGidDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UploadGidBankData(::grpc::ClientContext* context, const ::CGData::UploadGidBankDataRequest* request, ::CGData::UploadGidBankDataResponse* response, std::function<void(::grpc::Status)>) override;
      void UploadGidBankData(::grpc::ClientContext* context, const ::CGData::UploadGidBankDataRequest* request, ::CGData::UploadGidBankDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Publish(::grpc::ClientContext* context, const ::CGData::StringPub* request, ::CGData::StringPub* response, std::function<void(::grpc::Status)>) override;
      void Publish(::grpc::ClientContext* context, const ::CGData::StringPub* request, ::CGData::StringPub* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Subscribe(::grpc::ClientContext* context, const ::CGData::StringPub* request, ::grpc::ClientReadReactor< ::CGData::StringPub>* reactor) override;
      void SelectAccountGidData(::grpc::ClientContext* context, const ::CGData::SelectAccountGidDataRequest* request, ::CGData::SelectAccountGidDataResponse* response, std::function<void(::grpc::Status)>) override;
      void SelectAccountGidData(::grpc::ClientContext* context, const ::CGData::SelectAccountGidDataRequest* request, ::CGData::SelectAccountGidDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SelectGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest* request, ::CGData::SelectGidDataResponse* response, std::function<void(::grpc::Status)>) override;
      void SelectGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest* request, ::CGData::SelectGidDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SelectDstTypeGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest* request, ::CGData::SelectAccountGidDataResponse* response, std::function<void(::grpc::Status)>) override;
      void SelectDstTypeGidData(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest* request, ::CGData::SelectAccountGidDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::CGData::CGItemResponse>* AsyncGetCGItemDataRaw(::grpc::ClientContext* context, const ::CGData::CGItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGItemResponse>* PrepareAsyncGetCGItemDataRaw(::grpc::ClientContext* context, const ::CGData::CGItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>* AsyncGetConnectStateRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGVoidData>* PrepareAsyncGetConnectStateRaw(::grpc::ClientContext* context, const ::CGData::CGVoidData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGPetGradeCalcResponse>* AsyncGetPetGradeCalcDataRaw(::grpc::ClientContext* context, const ::CGData::CGPetGradeCalcRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGPetGradeCalcResponse>* PrepareAsyncGetPetGradeCalcDataRaw(::grpc::ClientContext* context, const ::CGData::CGPetGradeCalcRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGMapDataResponse>* AsyncGetServerStoreMapDataRaw(::grpc::ClientContext* context, const ::CGData::CGMapDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGMapDataResponse>* PrepareAsyncGetServerStoreMapDataRaw(::grpc::ClientContext* context, const ::CGData::CGMapDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGStoreItemResponse>* AsyncStoreCGItemDataRaw(::grpc::ClientContext* context, const ::CGData::CGStoreItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGStoreItemResponse>* PrepareAsyncStoreCGItemDataRaw(::grpc::ClientContext* context, const ::CGData::CGStoreItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGStoreMapResponse>* AsyncStoreCGMapDataRaw(::grpc::ClientContext* context, const ::CGData::CGStoreMapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::CGStoreMapResponse>* PrepareAsyncStoreCGMapDataRaw(::grpc::ClientContext* context, const ::CGData::CGStoreMapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::UploadGidDataResponse>* AsyncUploadGidDataRaw(::grpc::ClientContext* context, const ::CGData::UploadGidDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::UploadGidDataResponse>* PrepareAsyncUploadGidDataRaw(::grpc::ClientContext* context, const ::CGData::UploadGidDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::UploadGidBankDataResponse>* AsyncUploadGidBankDataRaw(::grpc::ClientContext* context, const ::CGData::UploadGidBankDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::UploadGidBankDataResponse>* PrepareAsyncUploadGidBankDataRaw(::grpc::ClientContext* context, const ::CGData::UploadGidBankDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::StringPub>* AsyncPublishRaw(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::StringPub>* PrepareAsyncPublishRaw(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::CGData::StringPub>* SubscribeRaw(::grpc::ClientContext* context, const ::CGData::StringPub& request) override;
    ::grpc::ClientAsyncReader< ::CGData::StringPub>* AsyncSubscribeRaw(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::CGData::StringPub>* PrepareAsyncSubscribeRaw(::grpc::ClientContext* context, const ::CGData::StringPub& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::SelectAccountGidDataResponse>* AsyncSelectAccountGidDataRaw(::grpc::ClientContext* context, const ::CGData::SelectAccountGidDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::SelectAccountGidDataResponse>* PrepareAsyncSelectAccountGidDataRaw(::grpc::ClientContext* context, const ::CGData::SelectAccountGidDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::SelectGidDataResponse>* AsyncSelectGidDataRaw(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::SelectGidDataResponse>* PrepareAsyncSelectGidDataRaw(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::SelectAccountGidDataResponse>* AsyncSelectDstTypeGidDataRaw(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CGData::SelectAccountGidDataResponse>* PrepareAsyncSelectDstTypeGidDataRaw(::grpc::ClientContext* context, const ::CGData::SelectGidDataRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetCGItemData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConnectState_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPetGradeCalcData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetServerStoreMapData_;
    const ::grpc::internal::RpcMethod rpcmethod_StoreCGItemData_;
    const ::grpc::internal::RpcMethod rpcmethod_StoreCGMapData_;
    const ::grpc::internal::RpcMethod rpcmethod_UploadGidData_;
    const ::grpc::internal::RpcMethod rpcmethod_UploadGidBankData_;
    const ::grpc::internal::RpcMethod rpcmethod_Publish_;
    const ::grpc::internal::RpcMethod rpcmethod_Subscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_SelectAccountGidData_;
    const ::grpc::internal::RpcMethod rpcmethod_SelectGidData_;
    const ::grpc::internal::RpcMethod rpcmethod_SelectDstTypeGidData_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // 根据item的id，获取item信息
    virtual ::grpc::Status GetCGItemData(::grpc::ServerContext* context, const ::CGData::CGItemRequest* request, ::CGData::CGItemResponse* response);
    virtual ::grpc::Status GetConnectState(::grpc::ServerContext* context, const ::CGData::CGVoidData* request, ::CGData::CGVoidData* response);
    // 获取所有宠物算档数据
    virtual ::grpc::Status GetPetGradeCalcData(::grpc::ServerContext* context, const ::CGData::CGPetGradeCalcRequest* request, ::CGData::CGPetGradeCalcResponse* response);
    // 获取服务端所有id和map名称的映射，用于本地缓存
    virtual ::grpc::Status GetServerStoreMapData(::grpc::ServerContext* context, const ::CGData::CGMapDataRequest* request, ::CGData::CGMapDataResponse* response);
    // 客户端向服务器发送当前包裹物品信息，服务端用于缓存和更新数据库
    virtual ::grpc::Status StoreCGItemData(::grpc::ServerContext* context, const ::CGData::CGStoreItemRequest* request, ::CGData::CGStoreItemResponse* response);
    // 客户端向服务器发送地图信息，服务端缓存更新
    virtual ::grpc::Status StoreCGMapData(::grpc::ServerContext* context, const ::CGData::CGStoreMapRequest* request, ::CGData::CGStoreMapResponse* response);
    // 定时上报当辅助信息
    virtual ::grpc::Status UploadGidData(::grpc::ServerContext* context, const ::CGData::UploadGidDataRequest* request, ::CGData::UploadGidDataResponse* response);
    virtual ::grpc::Status UploadGidBankData(::grpc::ServerContext* context, const ::CGData::UploadGidBankDataRequest* request, ::CGData::UploadGidBankDataResponse* response);
    // 发布是rpc的普通方法
    virtual ::grpc::Status Publish(::grpc::ServerContext* context, const ::CGData::StringPub* request, ::CGData::StringPub* response);
    // 订阅则是一个单向的流服务，服务端返回的数据可能很大
    virtual ::grpc::Status Subscribe(::grpc::ServerContext* context, const ::CGData::StringPub* request, ::grpc::ServerWriter< ::CGData::StringPub>* writer);
    // *****************客户端查询数据接口*************
    //
    // 查询指定账号下各GID的角色数据
    virtual ::grpc::Status SelectAccountGidData(::grpc::ServerContext* context, const ::CGData::SelectAccountGidDataRequest* request, ::CGData::SelectAccountGidDataResponse* response);
    virtual ::grpc::Status SelectGidData(::grpc::ServerContext* context, const ::CGData::SelectGidDataRequest* request, ::CGData::SelectGidDataResponse* response);
    // 查询指定类型的gid角色数据 例如：当前gid是哥布林仓库专用，则查询所有此类型账号 一个角色可以是全部类型
    virtual ::grpc::Status SelectDstTypeGidData(::grpc::ServerContext* context, const ::CGData::SelectGidDataRequest* request, ::CGData::SelectAccountGidDataResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCGItemData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCGItemData() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetCGItemData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCGItemData(::grpc::ServerContext* /*context*/, const ::CGData::CGItemRequest* /*request*/, ::CGData::CGItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCGItemData(::grpc::ServerContext* context, ::CGData::CGItemRequest* request, ::grpc::ServerAsyncResponseWriter< ::CGData::CGItemResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConnectState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConnectState() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetConnectState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConnectState(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConnectState(::grpc::ServerContext* context, ::CGData::CGVoidData* request, ::grpc::ServerAsyncResponseWriter< ::CGData::CGVoidData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPetGradeCalcData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPetGradeCalcData() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetPetGradeCalcData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPetGradeCalcData(::grpc::ServerContext* /*context*/, const ::CGData::CGPetGradeCalcRequest* /*request*/, ::CGData::CGPetGradeCalcResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPetGradeCalcData(::grpc::ServerContext* context, ::CGData::CGPetGradeCalcRequest* request, ::grpc::ServerAsyncResponseWriter< ::CGData::CGPetGradeCalcResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetServerStoreMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetServerStoreMapData() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetServerStoreMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServerStoreMapData(::grpc::ServerContext* /*context*/, const ::CGData::CGMapDataRequest* /*request*/, ::CGData::CGMapDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServerStoreMapData(::grpc::ServerContext* context, ::CGData::CGMapDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::CGData::CGMapDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StoreCGItemData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StoreCGItemData() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_StoreCGItemData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreCGItemData(::grpc::ServerContext* /*context*/, const ::CGData::CGStoreItemRequest* /*request*/, ::CGData::CGStoreItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreCGItemData(::grpc::ServerContext* context, ::CGData::CGStoreItemRequest* request, ::grpc::ServerAsyncResponseWriter< ::CGData::CGStoreItemResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StoreCGMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StoreCGMapData() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_StoreCGMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreCGMapData(::grpc::ServerContext* /*context*/, const ::CGData::CGStoreMapRequest* /*request*/, ::CGData::CGStoreMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreCGMapData(::grpc::ServerContext* context, ::CGData::CGStoreMapRequest* request, ::grpc::ServerAsyncResponseWriter< ::CGData::CGStoreMapResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UploadGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UploadGidData() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_UploadGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadGidData(::grpc::ServerContext* /*context*/, const ::CGData::UploadGidDataRequest* /*request*/, ::CGData::UploadGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadGidData(::grpc::ServerContext* context, ::CGData::UploadGidDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::CGData::UploadGidDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UploadGidBankData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UploadGidBankData() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_UploadGidBankData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadGidBankData(::grpc::ServerContext* /*context*/, const ::CGData::UploadGidBankDataRequest* /*request*/, ::CGData::UploadGidBankDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadGidBankData(::grpc::ServerContext* context, ::CGData::UploadGidBankDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::CGData::UploadGidBankDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Publish() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_Publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Publish(::grpc::ServerContext* /*context*/, const ::CGData::StringPub* /*request*/, ::CGData::StringPub* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPublish(::grpc::ServerContext* context, ::CGData::StringPub* request, ::grpc::ServerAsyncResponseWriter< ::CGData::StringPub>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Subscribe() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::CGData::StringPub* /*request*/, ::grpc::ServerWriter< ::CGData::StringPub>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribe(::grpc::ServerContext* context, ::CGData::StringPub* request, ::grpc::ServerAsyncWriter< ::CGData::StringPub>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(9, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SelectAccountGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SelectAccountGidData() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_SelectAccountGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectAccountGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectAccountGidDataRequest* /*request*/, ::CGData::SelectAccountGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSelectAccountGidData(::grpc::ServerContext* context, ::CGData::SelectAccountGidDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::CGData::SelectAccountGidDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SelectGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SelectGidData() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_SelectGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectGidDataRequest* /*request*/, ::CGData::SelectGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSelectGidData(::grpc::ServerContext* context, ::CGData::SelectGidDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::CGData::SelectGidDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SelectDstTypeGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SelectDstTypeGidData() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_SelectDstTypeGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectDstTypeGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectGidDataRequest* /*request*/, ::CGData::SelectAccountGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSelectDstTypeGidData(::grpc::ServerContext* context, ::CGData::SelectGidDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::CGData::SelectAccountGidDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetCGItemData<WithAsyncMethod_GetConnectState<WithAsyncMethod_GetPetGradeCalcData<WithAsyncMethod_GetServerStoreMapData<WithAsyncMethod_StoreCGItemData<WithAsyncMethod_StoreCGMapData<WithAsyncMethod_UploadGidData<WithAsyncMethod_UploadGidBankData<WithAsyncMethod_Publish<WithAsyncMethod_Subscribe<WithAsyncMethod_SelectAccountGidData<WithAsyncMethod_SelectGidData<WithAsyncMethod_SelectDstTypeGidData<Service > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetCGItemData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCGItemData() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::CGItemRequest, ::CGData::CGItemResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::CGItemRequest* request, ::CGData::CGItemResponse* response) { return this->GetCGItemData(context, request, response); }));}
    void SetMessageAllocatorFor_GetCGItemData(
        ::grpc::MessageAllocator< ::CGData::CGItemRequest, ::CGData::CGItemResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::CGItemRequest, ::CGData::CGItemResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCGItemData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCGItemData(::grpc::ServerContext* /*context*/, const ::CGData::CGItemRequest* /*request*/, ::CGData::CGItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCGItemData(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::CGItemRequest* /*request*/, ::CGData::CGItemResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetConnectState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetConnectState() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::CGVoidData, ::CGData::CGVoidData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::CGVoidData* request, ::CGData::CGVoidData* response) { return this->GetConnectState(context, request, response); }));}
    void SetMessageAllocatorFor_GetConnectState(
        ::grpc::MessageAllocator< ::CGData::CGVoidData, ::CGData::CGVoidData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::CGVoidData, ::CGData::CGVoidData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetConnectState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConnectState(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConnectState(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGVoidData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPetGradeCalcData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPetGradeCalcData() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::CGPetGradeCalcRequest, ::CGData::CGPetGradeCalcResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::CGPetGradeCalcRequest* request, ::CGData::CGPetGradeCalcResponse* response) { return this->GetPetGradeCalcData(context, request, response); }));}
    void SetMessageAllocatorFor_GetPetGradeCalcData(
        ::grpc::MessageAllocator< ::CGData::CGPetGradeCalcRequest, ::CGData::CGPetGradeCalcResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::CGPetGradeCalcRequest, ::CGData::CGPetGradeCalcResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPetGradeCalcData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPetGradeCalcData(::grpc::ServerContext* /*context*/, const ::CGData::CGPetGradeCalcRequest* /*request*/, ::CGData::CGPetGradeCalcResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPetGradeCalcData(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::CGPetGradeCalcRequest* /*request*/, ::CGData::CGPetGradeCalcResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetServerStoreMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetServerStoreMapData() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::CGMapDataRequest, ::CGData::CGMapDataResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::CGMapDataRequest* request, ::CGData::CGMapDataResponse* response) { return this->GetServerStoreMapData(context, request, response); }));}
    void SetMessageAllocatorFor_GetServerStoreMapData(
        ::grpc::MessageAllocator< ::CGData::CGMapDataRequest, ::CGData::CGMapDataResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::CGMapDataRequest, ::CGData::CGMapDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetServerStoreMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServerStoreMapData(::grpc::ServerContext* /*context*/, const ::CGData::CGMapDataRequest* /*request*/, ::CGData::CGMapDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServerStoreMapData(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::CGMapDataRequest* /*request*/, ::CGData::CGMapDataResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StoreCGItemData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StoreCGItemData() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::CGStoreItemRequest, ::CGData::CGStoreItemResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::CGStoreItemRequest* request, ::CGData::CGStoreItemResponse* response) { return this->StoreCGItemData(context, request, response); }));}
    void SetMessageAllocatorFor_StoreCGItemData(
        ::grpc::MessageAllocator< ::CGData::CGStoreItemRequest, ::CGData::CGStoreItemResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::CGStoreItemRequest, ::CGData::CGStoreItemResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StoreCGItemData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreCGItemData(::grpc::ServerContext* /*context*/, const ::CGData::CGStoreItemRequest* /*request*/, ::CGData::CGStoreItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StoreCGItemData(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::CGStoreItemRequest* /*request*/, ::CGData::CGStoreItemResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StoreCGMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StoreCGMapData() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::CGStoreMapRequest, ::CGData::CGStoreMapResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::CGStoreMapRequest* request, ::CGData::CGStoreMapResponse* response) { return this->StoreCGMapData(context, request, response); }));}
    void SetMessageAllocatorFor_StoreCGMapData(
        ::grpc::MessageAllocator< ::CGData::CGStoreMapRequest, ::CGData::CGStoreMapResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::CGStoreMapRequest, ::CGData::CGStoreMapResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StoreCGMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreCGMapData(::grpc::ServerContext* /*context*/, const ::CGData::CGStoreMapRequest* /*request*/, ::CGData::CGStoreMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StoreCGMapData(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::CGStoreMapRequest* /*request*/, ::CGData::CGStoreMapResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UploadGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UploadGidData() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::UploadGidDataRequest, ::CGData::UploadGidDataResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::UploadGidDataRequest* request, ::CGData::UploadGidDataResponse* response) { return this->UploadGidData(context, request, response); }));}
    void SetMessageAllocatorFor_UploadGidData(
        ::grpc::MessageAllocator< ::CGData::UploadGidDataRequest, ::CGData::UploadGidDataResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::UploadGidDataRequest, ::CGData::UploadGidDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UploadGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadGidData(::grpc::ServerContext* /*context*/, const ::CGData::UploadGidDataRequest* /*request*/, ::CGData::UploadGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadGidData(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::UploadGidDataRequest* /*request*/, ::CGData::UploadGidDataResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UploadGidBankData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UploadGidBankData() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::UploadGidBankDataRequest, ::CGData::UploadGidBankDataResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::UploadGidBankDataRequest* request, ::CGData::UploadGidBankDataResponse* response) { return this->UploadGidBankData(context, request, response); }));}
    void SetMessageAllocatorFor_UploadGidBankData(
        ::grpc::MessageAllocator< ::CGData::UploadGidBankDataRequest, ::CGData::UploadGidBankDataResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::UploadGidBankDataRequest, ::CGData::UploadGidBankDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UploadGidBankData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadGidBankData(::grpc::ServerContext* /*context*/, const ::CGData::UploadGidBankDataRequest* /*request*/, ::CGData::UploadGidBankDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadGidBankData(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::UploadGidBankDataRequest* /*request*/, ::CGData::UploadGidBankDataResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Publish() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::StringPub, ::CGData::StringPub>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::StringPub* request, ::CGData::StringPub* response) { return this->Publish(context, request, response); }));}
    void SetMessageAllocatorFor_Publish(
        ::grpc::MessageAllocator< ::CGData::StringPub, ::CGData::StringPub>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::StringPub, ::CGData::StringPub>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Publish(::grpc::ServerContext* /*context*/, const ::CGData::StringPub* /*request*/, ::CGData::StringPub* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Publish(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::StringPub* /*request*/, ::CGData::StringPub* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Subscribe() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackServerStreamingHandler< ::CGData::StringPub, ::CGData::StringPub>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::StringPub* request) { return this->Subscribe(context, request); }));
    }
    ~WithCallbackMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::CGData::StringPub* /*request*/, ::grpc::ServerWriter< ::CGData::StringPub>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::CGData::StringPub>* Subscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::StringPub* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SelectAccountGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SelectAccountGidData() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::SelectAccountGidDataRequest, ::CGData::SelectAccountGidDataResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::SelectAccountGidDataRequest* request, ::CGData::SelectAccountGidDataResponse* response) { return this->SelectAccountGidData(context, request, response); }));}
    void SetMessageAllocatorFor_SelectAccountGidData(
        ::grpc::MessageAllocator< ::CGData::SelectAccountGidDataRequest, ::CGData::SelectAccountGidDataResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::SelectAccountGidDataRequest, ::CGData::SelectAccountGidDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SelectAccountGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectAccountGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectAccountGidDataRequest* /*request*/, ::CGData::SelectAccountGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SelectAccountGidData(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::SelectAccountGidDataRequest* /*request*/, ::CGData::SelectAccountGidDataResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SelectGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SelectGidData() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::SelectGidDataRequest, ::CGData::SelectGidDataResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::SelectGidDataRequest* request, ::CGData::SelectGidDataResponse* response) { return this->SelectGidData(context, request, response); }));}
    void SetMessageAllocatorFor_SelectGidData(
        ::grpc::MessageAllocator< ::CGData::SelectGidDataRequest, ::CGData::SelectGidDataResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::SelectGidDataRequest, ::CGData::SelectGidDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SelectGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectGidDataRequest* /*request*/, ::CGData::SelectGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SelectGidData(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::SelectGidDataRequest* /*request*/, ::CGData::SelectGidDataResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SelectDstTypeGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SelectDstTypeGidData() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::CGData::SelectGidDataRequest, ::CGData::SelectAccountGidDataResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CGData::SelectGidDataRequest* request, ::CGData::SelectAccountGidDataResponse* response) { return this->SelectDstTypeGidData(context, request, response); }));}
    void SetMessageAllocatorFor_SelectDstTypeGidData(
        ::grpc::MessageAllocator< ::CGData::SelectGidDataRequest, ::CGData::SelectAccountGidDataResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CGData::SelectGidDataRequest, ::CGData::SelectAccountGidDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SelectDstTypeGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectDstTypeGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectGidDataRequest* /*request*/, ::CGData::SelectAccountGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SelectDstTypeGidData(
      ::grpc::CallbackServerContext* /*context*/, const ::CGData::SelectGidDataRequest* /*request*/, ::CGData::SelectAccountGidDataResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetCGItemData<WithCallbackMethod_GetConnectState<WithCallbackMethod_GetPetGradeCalcData<WithCallbackMethod_GetServerStoreMapData<WithCallbackMethod_StoreCGItemData<WithCallbackMethod_StoreCGMapData<WithCallbackMethod_UploadGidData<WithCallbackMethod_UploadGidBankData<WithCallbackMethod_Publish<WithCallbackMethod_Subscribe<WithCallbackMethod_SelectAccountGidData<WithCallbackMethod_SelectGidData<WithCallbackMethod_SelectDstTypeGidData<Service > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetCGItemData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCGItemData() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetCGItemData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCGItemData(::grpc::ServerContext* /*context*/, const ::CGData::CGItemRequest* /*request*/, ::CGData::CGItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConnectState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConnectState() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetConnectState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConnectState(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPetGradeCalcData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPetGradeCalcData() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetPetGradeCalcData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPetGradeCalcData(::grpc::ServerContext* /*context*/, const ::CGData::CGPetGradeCalcRequest* /*request*/, ::CGData::CGPetGradeCalcResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetServerStoreMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetServerStoreMapData() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetServerStoreMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServerStoreMapData(::grpc::ServerContext* /*context*/, const ::CGData::CGMapDataRequest* /*request*/, ::CGData::CGMapDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StoreCGItemData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StoreCGItemData() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_StoreCGItemData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreCGItemData(::grpc::ServerContext* /*context*/, const ::CGData::CGStoreItemRequest* /*request*/, ::CGData::CGStoreItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StoreCGMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StoreCGMapData() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_StoreCGMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreCGMapData(::grpc::ServerContext* /*context*/, const ::CGData::CGStoreMapRequest* /*request*/, ::CGData::CGStoreMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UploadGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UploadGidData() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_UploadGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadGidData(::grpc::ServerContext* /*context*/, const ::CGData::UploadGidDataRequest* /*request*/, ::CGData::UploadGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UploadGidBankData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UploadGidBankData() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_UploadGidBankData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadGidBankData(::grpc::ServerContext* /*context*/, const ::CGData::UploadGidBankDataRequest* /*request*/, ::CGData::UploadGidBankDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Publish() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_Publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Publish(::grpc::ServerContext* /*context*/, const ::CGData::StringPub* /*request*/, ::CGData::StringPub* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Subscribe() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::CGData::StringPub* /*request*/, ::grpc::ServerWriter< ::CGData::StringPub>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SelectAccountGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SelectAccountGidData() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_SelectAccountGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectAccountGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectAccountGidDataRequest* /*request*/, ::CGData::SelectAccountGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SelectGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SelectGidData() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_SelectGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectGidDataRequest* /*request*/, ::CGData::SelectGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SelectDstTypeGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SelectDstTypeGidData() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_SelectDstTypeGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectDstTypeGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectGidDataRequest* /*request*/, ::CGData::SelectAccountGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCGItemData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCGItemData() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetCGItemData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCGItemData(::grpc::ServerContext* /*context*/, const ::CGData::CGItemRequest* /*request*/, ::CGData::CGItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCGItemData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConnectState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConnectState() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetConnectState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConnectState(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConnectState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPetGradeCalcData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPetGradeCalcData() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetPetGradeCalcData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPetGradeCalcData(::grpc::ServerContext* /*context*/, const ::CGData::CGPetGradeCalcRequest* /*request*/, ::CGData::CGPetGradeCalcResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPetGradeCalcData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetServerStoreMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetServerStoreMapData() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetServerStoreMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServerStoreMapData(::grpc::ServerContext* /*context*/, const ::CGData::CGMapDataRequest* /*request*/, ::CGData::CGMapDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServerStoreMapData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StoreCGItemData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StoreCGItemData() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_StoreCGItemData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreCGItemData(::grpc::ServerContext* /*context*/, const ::CGData::CGStoreItemRequest* /*request*/, ::CGData::CGStoreItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreCGItemData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StoreCGMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StoreCGMapData() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_StoreCGMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreCGMapData(::grpc::ServerContext* /*context*/, const ::CGData::CGStoreMapRequest* /*request*/, ::CGData::CGStoreMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreCGMapData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UploadGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UploadGidData() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_UploadGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadGidData(::grpc::ServerContext* /*context*/, const ::CGData::UploadGidDataRequest* /*request*/, ::CGData::UploadGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadGidData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UploadGidBankData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UploadGidBankData() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_UploadGidBankData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadGidBankData(::grpc::ServerContext* /*context*/, const ::CGData::UploadGidBankDataRequest* /*request*/, ::CGData::UploadGidBankDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadGidBankData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Publish() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_Publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Publish(::grpc::ServerContext* /*context*/, const ::CGData::StringPub* /*request*/, ::CGData::StringPub* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPublish(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Subscribe() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::CGData::StringPub* /*request*/, ::grpc::ServerWriter< ::CGData::StringPub>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(9, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SelectAccountGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SelectAccountGidData() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_SelectAccountGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectAccountGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectAccountGidDataRequest* /*request*/, ::CGData::SelectAccountGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSelectAccountGidData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SelectGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SelectGidData() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_SelectGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectGidDataRequest* /*request*/, ::CGData::SelectGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSelectGidData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SelectDstTypeGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SelectDstTypeGidData() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_SelectDstTypeGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectDstTypeGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectGidDataRequest* /*request*/, ::CGData::SelectAccountGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSelectDstTypeGidData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCGItemData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCGItemData() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCGItemData(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCGItemData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCGItemData(::grpc::ServerContext* /*context*/, const ::CGData::CGItemRequest* /*request*/, ::CGData::CGItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCGItemData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetConnectState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetConnectState() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConnectState(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetConnectState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConnectState(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConnectState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPetGradeCalcData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPetGradeCalcData() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPetGradeCalcData(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPetGradeCalcData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPetGradeCalcData(::grpc::ServerContext* /*context*/, const ::CGData::CGPetGradeCalcRequest* /*request*/, ::CGData::CGPetGradeCalcResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPetGradeCalcData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetServerStoreMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetServerStoreMapData() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetServerStoreMapData(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetServerStoreMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServerStoreMapData(::grpc::ServerContext* /*context*/, const ::CGData::CGMapDataRequest* /*request*/, ::CGData::CGMapDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServerStoreMapData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StoreCGItemData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StoreCGItemData() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StoreCGItemData(context, request, response); }));
    }
    ~WithRawCallbackMethod_StoreCGItemData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreCGItemData(::grpc::ServerContext* /*context*/, const ::CGData::CGStoreItemRequest* /*request*/, ::CGData::CGStoreItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StoreCGItemData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StoreCGMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StoreCGMapData() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StoreCGMapData(context, request, response); }));
    }
    ~WithRawCallbackMethod_StoreCGMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreCGMapData(::grpc::ServerContext* /*context*/, const ::CGData::CGStoreMapRequest* /*request*/, ::CGData::CGStoreMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StoreCGMapData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UploadGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UploadGidData() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UploadGidData(context, request, response); }));
    }
    ~WithRawCallbackMethod_UploadGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadGidData(::grpc::ServerContext* /*context*/, const ::CGData::UploadGidDataRequest* /*request*/, ::CGData::UploadGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadGidData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UploadGidBankData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UploadGidBankData() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UploadGidBankData(context, request, response); }));
    }
    ~WithRawCallbackMethod_UploadGidBankData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadGidBankData(::grpc::ServerContext* /*context*/, const ::CGData::UploadGidBankDataRequest* /*request*/, ::CGData::UploadGidBankDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadGidBankData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Publish() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Publish(context, request, response); }));
    }
    ~WithRawCallbackMethod_Publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Publish(::grpc::ServerContext* /*context*/, const ::CGData::StringPub* /*request*/, ::CGData::StringPub* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Publish(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Subscribe() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->Subscribe(context, request); }));
    }
    ~WithRawCallbackMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::CGData::StringPub* /*request*/, ::grpc::ServerWriter< ::CGData::StringPub>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* Subscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SelectAccountGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SelectAccountGidData() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SelectAccountGidData(context, request, response); }));
    }
    ~WithRawCallbackMethod_SelectAccountGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectAccountGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectAccountGidDataRequest* /*request*/, ::CGData::SelectAccountGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SelectAccountGidData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SelectGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SelectGidData() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SelectGidData(context, request, response); }));
    }
    ~WithRawCallbackMethod_SelectGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectGidDataRequest* /*request*/, ::CGData::SelectGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SelectGidData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SelectDstTypeGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SelectDstTypeGidData() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SelectDstTypeGidData(context, request, response); }));
    }
    ~WithRawCallbackMethod_SelectDstTypeGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectDstTypeGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectGidDataRequest* /*request*/, ::CGData::SelectAccountGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SelectDstTypeGidData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCGItemData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCGItemData() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::CGItemRequest, ::CGData::CGItemResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::CGItemRequest, ::CGData::CGItemResponse>* streamer) {
                       return this->StreamedGetCGItemData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCGItemData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCGItemData(::grpc::ServerContext* /*context*/, const ::CGData::CGItemRequest* /*request*/, ::CGData::CGItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCGItemData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::CGItemRequest,::CGData::CGItemResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConnectState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConnectState() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::CGVoidData, ::CGData::CGVoidData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::CGVoidData, ::CGData::CGVoidData>* streamer) {
                       return this->StreamedGetConnectState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetConnectState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConnectState(::grpc::ServerContext* /*context*/, const ::CGData::CGVoidData* /*request*/, ::CGData::CGVoidData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConnectState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::CGVoidData,::CGData::CGVoidData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPetGradeCalcData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPetGradeCalcData() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::CGPetGradeCalcRequest, ::CGData::CGPetGradeCalcResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::CGPetGradeCalcRequest, ::CGData::CGPetGradeCalcResponse>* streamer) {
                       return this->StreamedGetPetGradeCalcData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPetGradeCalcData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPetGradeCalcData(::grpc::ServerContext* /*context*/, const ::CGData::CGPetGradeCalcRequest* /*request*/, ::CGData::CGPetGradeCalcResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPetGradeCalcData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::CGPetGradeCalcRequest,::CGData::CGPetGradeCalcResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetServerStoreMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetServerStoreMapData() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::CGMapDataRequest, ::CGData::CGMapDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::CGMapDataRequest, ::CGData::CGMapDataResponse>* streamer) {
                       return this->StreamedGetServerStoreMapData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetServerStoreMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetServerStoreMapData(::grpc::ServerContext* /*context*/, const ::CGData::CGMapDataRequest* /*request*/, ::CGData::CGMapDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetServerStoreMapData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::CGMapDataRequest,::CGData::CGMapDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StoreCGItemData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StoreCGItemData() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::CGStoreItemRequest, ::CGData::CGStoreItemResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::CGStoreItemRequest, ::CGData::CGStoreItemResponse>* streamer) {
                       return this->StreamedStoreCGItemData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StoreCGItemData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StoreCGItemData(::grpc::ServerContext* /*context*/, const ::CGData::CGStoreItemRequest* /*request*/, ::CGData::CGStoreItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStoreCGItemData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::CGStoreItemRequest,::CGData::CGStoreItemResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StoreCGMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StoreCGMapData() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::CGStoreMapRequest, ::CGData::CGStoreMapResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::CGStoreMapRequest, ::CGData::CGStoreMapResponse>* streamer) {
                       return this->StreamedStoreCGMapData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StoreCGMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StoreCGMapData(::grpc::ServerContext* /*context*/, const ::CGData::CGStoreMapRequest* /*request*/, ::CGData::CGStoreMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStoreCGMapData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::CGStoreMapRequest,::CGData::CGStoreMapResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UploadGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UploadGidData() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::UploadGidDataRequest, ::CGData::UploadGidDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::UploadGidDataRequest, ::CGData::UploadGidDataResponse>* streamer) {
                       return this->StreamedUploadGidData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UploadGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UploadGidData(::grpc::ServerContext* /*context*/, const ::CGData::UploadGidDataRequest* /*request*/, ::CGData::UploadGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUploadGidData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::UploadGidDataRequest,::CGData::UploadGidDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UploadGidBankData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UploadGidBankData() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::UploadGidBankDataRequest, ::CGData::UploadGidBankDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::UploadGidBankDataRequest, ::CGData::UploadGidBankDataResponse>* streamer) {
                       return this->StreamedUploadGidBankData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UploadGidBankData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UploadGidBankData(::grpc::ServerContext* /*context*/, const ::CGData::UploadGidBankDataRequest* /*request*/, ::CGData::UploadGidBankDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUploadGidBankData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::UploadGidBankDataRequest,::CGData::UploadGidBankDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Publish() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::StringPub, ::CGData::StringPub>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::StringPub, ::CGData::StringPub>* streamer) {
                       return this->StreamedPublish(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Publish(::grpc::ServerContext* /*context*/, const ::CGData::StringPub* /*request*/, ::CGData::StringPub* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPublish(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::StringPub,::CGData::StringPub>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SelectAccountGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SelectAccountGidData() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::SelectAccountGidDataRequest, ::CGData::SelectAccountGidDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::SelectAccountGidDataRequest, ::CGData::SelectAccountGidDataResponse>* streamer) {
                       return this->StreamedSelectAccountGidData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SelectAccountGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SelectAccountGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectAccountGidDataRequest* /*request*/, ::CGData::SelectAccountGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSelectAccountGidData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::SelectAccountGidDataRequest,::CGData::SelectAccountGidDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SelectGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SelectGidData() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::SelectGidDataRequest, ::CGData::SelectGidDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::SelectGidDataRequest, ::CGData::SelectGidDataResponse>* streamer) {
                       return this->StreamedSelectGidData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SelectGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SelectGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectGidDataRequest* /*request*/, ::CGData::SelectGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSelectGidData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::SelectGidDataRequest,::CGData::SelectGidDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SelectDstTypeGidData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SelectDstTypeGidData() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CGData::SelectGidDataRequest, ::CGData::SelectAccountGidDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CGData::SelectGidDataRequest, ::CGData::SelectAccountGidDataResponse>* streamer) {
                       return this->StreamedSelectDstTypeGidData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SelectDstTypeGidData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SelectDstTypeGidData(::grpc::ServerContext* /*context*/, const ::CGData::SelectGidDataRequest* /*request*/, ::CGData::SelectAccountGidDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSelectDstTypeGidData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CGData::SelectGidDataRequest,::CGData::SelectAccountGidDataResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetCGItemData<WithStreamedUnaryMethod_GetConnectState<WithStreamedUnaryMethod_GetPetGradeCalcData<WithStreamedUnaryMethod_GetServerStoreMapData<WithStreamedUnaryMethod_StoreCGItemData<WithStreamedUnaryMethod_StoreCGMapData<WithStreamedUnaryMethod_UploadGidData<WithStreamedUnaryMethod_UploadGidBankData<WithStreamedUnaryMethod_Publish<WithStreamedUnaryMethod_SelectAccountGidData<WithStreamedUnaryMethod_SelectGidData<WithStreamedUnaryMethod_SelectDstTypeGidData<Service > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_Subscribe() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::CGData::StringPub, ::CGData::StringPub>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::CGData::StringPub, ::CGData::StringPub>* streamer) {
                       return this->StreamedSubscribe(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::CGData::StringPub* /*request*/, ::grpc::ServerWriter< ::CGData::StringPub>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribe(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::CGData::StringPub,::CGData::StringPub>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_Subscribe<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetCGItemData<WithStreamedUnaryMethod_GetConnectState<WithStreamedUnaryMethod_GetPetGradeCalcData<WithStreamedUnaryMethod_GetServerStoreMapData<WithStreamedUnaryMethod_StoreCGItemData<WithStreamedUnaryMethod_StoreCGMapData<WithStreamedUnaryMethod_UploadGidData<WithStreamedUnaryMethod_UploadGidBankData<WithStreamedUnaryMethod_Publish<WithSplitStreamingMethod_Subscribe<WithStreamedUnaryMethod_SelectAccountGidData<WithStreamedUnaryMethod_SelectGidData<WithStreamedUnaryMethod_SelectDstTypeGidData<Service > > > > > > > > > > > > > StreamedService;
};

}  // namespace CGData


#endif  // GRPC_CGData_2eproto__INCLUDED
